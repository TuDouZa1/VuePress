---
title: '0327'
createTime: 2025/07/08 17:03:15
permalink: /article/v9ui89qn/
---
<style>
img
{
    width: 80%;
    margin-left: 10%;
}
</style>

<!--头图
<div style = "overflow:hidden;max-height: 350px;margin-top:-30px;">
<img style = "width: 100%;margin-left: auto;height: auto;margin-top:-50px;" src = "https://img-baofun.zhhainiao.com/fs/883b72b386af552d2ebefb665ec6aad7.jpg">
</div>
-->

# 代码随想录的总结
### [数组](#数组) [链表](#链表) [哈希表](#哈希表) [字符串](#字符串) [双指针](#双指针) [栈和队列](#栈和队列)
---
## 数组
#### 快慢指针
大部分用于原地修改数组使用
#### 左右指针
二分查找
反转数组
回文数判断
#### 滑动窗口
#### 特殊顺序数组
螺旋矩阵

## 链表

## 哈希表
#### 常见的三种哈希结构
* 数组
* set (集合)
* map (映射)
#### 表格对比

|<center>集合 (set)|是否有序|数值是否可以重复|查询效率|增删效率|
|---|---|---|---|---|
|set|有序|不可重复|O(log n)|O(log n)|
|multiset|有序|可以重复|O(log n)|O(log n)|
|unordered_set|无序|不可重复|O(1)|O(1)|

|<center>映射 (map)|是否有序|数值是否可以重复|查询效率|增删效率|
|---|---|---|---|---|
|map|key有序|key不可重复|O(log n)|O(log n)|
|multimap|key有序|key可以重复|O(log n)|O(log n)|
|unordered_map|key无序|key不可重复|O(1)|O(1)|

std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。
map同理
#### set 和 map 的区别
set 存储元素 (key)
map 存储元素 (key) 和下标 (value)
#### 一些使用 map 时的注意事项
* ##### iter
```c++
unordered_map<int> map;
auto iter = map.begin();
return {iter->first, iter->second};
```
`iter->first` 返回 iter 指向的 key (元素)
`iter->second` 返回 iter 指向的 value (下标)
* ##### pair
pair 是一个有 first 和 second 两个成员的 struct
pair 用于一次性返回以两个为一组的数据，可以使用 pair 为 map 插入元素
```c++
#include <utility>
#include <iostream>
#include <unordered_map>
using namespace std;
int main()
{
	pair<int, int> nums;
	nums.first = "123";
	nums.second = "2";
	cout << nums.first << endl; // 123
	cout << nums.second << endl; // 2
    unordered_map<int, int> map;
    map.insert(nums);
    map.insert(pair<int, int>(123, 2)); // 效果同上
}
```

## 字符串
#### KMP 算法
```c++
void getNext(int* next, const string& str)
{
    int j = -1;
    next[0] = j;
    while (j >= 0 && str[i] != str[j + 1])   j = next[j];
    if (str[i] == str[j + 1])   j++;
    next[i] = j;
}
int KMP(string str1, string str2)
{
    if (str2.size() == 0)   return 0;
    int next[str2.size()];
    getNext(next, str2);
    int j = -1;
    for (int i = 0; i < str1.size(); i++)
    {
        while (j >= 0 && str1[i] != str2[j + 1])    j = next[j];
        if (str1[i] == str2[j + 1])    j++;
        if (j == str2.size() - 1)   return (i - str2.size() + 1);
    }
    return -1;
}
```

## 双指针

## 栈和队列
#### STACK 的基本函数
    push(const value_type& val): 将元素压入栈顶。
    pop(): 弹出栈顶元素。如果栈为空，则此操作未定义（通常会导致运行时误）。
    top(): 返回栈顶元素的引用。如果栈为空，则此操作未定义。
    empty() const: 检查栈是否为空。
    size() const: 返回栈中元素的数量。
演示代码
```c++
#include <iostream>
#include <stack>

int main()
{
    std::stack<int> s;

    s.push(1);
    s.push(2);
    s.push(3);

    std::cout << s.top() << std::endl; // 3

    s.pop(); // 弹出顶部元素

    std::cout << s.top() << std::endl; // 2

    if (s.empty())
        std::cout << "Stack is empty." << std::endl;
    else
        std::cout << "Stack size: " << s.size() << std::endl; // 输出: 2

    return 0;
}
```
#### 应用场景
匹配问题
#### QUEUE 的基本函数
    push(const value_type& val): 在队列尾部添加一个元素。
    pop(): 移除队列头部的元素。如果队列为空，则此操作未定义。
    front(): 返回队列头部元素的引用。如果队列为空，则此操作未定义。
    back(): 返回队列尾部元素的引用。如果队列为空，则此操作未定义。
    empty() const: 检查队列是否为空。
    size() const: 返回队列中元素的数量。
演示代码
```c++
#include <iostream>
#include <queue>

int main()
{
    std::queue<int> q;

    q.push(1);
    q.push(2);
    q.push(3);

    std::cout << q.front() << std::endl; // 查看头部元素 1
    std::cout << q.back() << std::endl;  // 查看尾部元素 3

    q.pop(); // 出队元素

    std::cout << q.front() << std::endl; // 查看头部元素 2

    if (q.empty())
        std::cout << "Queue is empty." << std::endl;
    else
        std::cout << "Queue size:" << q.size() << std::endl; // 2

    return 0;
}
```
#### DEQUE 的基本函数
在另一个 MD 中有详细介绍